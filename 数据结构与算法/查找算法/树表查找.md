
# 一 二叉排序树

二叉排序树，又叫二叉查找树，二叉搜索树，是一种有特定规则的二叉树，定义如下：

1. 它是一棵二叉树，或者是空树。
   
2. 左子树所有节点的值都小于它的根节点，右子树所有节点的值都大于它的根节点。

3. 左右子树也是一棵二叉查找树。


![](../.img/二叉排序树.gif)

二叉排序树的特点是
* 一直往左儿子往下找左儿子，可以找到最小的元素；
* 一直往右儿子找右儿子，可以找到最大的元素。

## 二叉树排序树实现

以下是一个二叉排序树的表示：
```go
package main

// BinarySearchTree 二叉查找树
type BinarySearchTree struct {
	Root *BinarySearchTreeNode // 树根节点
}

// BinarySearchTreeNode 二叉查找树节点
type BinarySearchTreeNode struct {
	Value int64                 // 值
	Times int64                 // 值出现的次数
	Left  *BinarySearchTreeNode // 左子树
	Right *BinarySearchTreeNode // 右字树
}

// NewBinarySearchTree 初始化一个二叉查找树
func NewBinarySearchTree() (t *BinarySearchTree) {
	t = new(BinarySearchTree)
	t.Root = nil
	return
}
```

### 创建二叉排序树
一个节点代表一个元素，节点的 `Value` 值是用来进行二叉查找的关键，
当 `Value` 值重复时，我们将值出现的次数 `Times` 加 `1`，添加节点代码如下:
```go
// Add 给树添加结点
func (tree *BinarySearchTree) Add(value int64)  {
	// 根结点为空 添加根节点并返回
	if tree.Root == nil {
		tree.Root = &BinarySearchTreeNode{Value: value}
		return
	}
	// 否则 添加子结点
	tree.Root.addNode(value)
}

// addNode 给结点添加子结点
func (node *BinarySearchTreeNode) addNode(value int64)  {
	// 值 比当前结点的值 小
	// 添加在左子结点
	if value < node.Value {
		if node.Left == nil {
			// 左子树为空添加
			node.Left = &BinarySearchTreeNode{Value: value}
		} else {
			// 否则 继续递归寻找
			node.Left.addNode(value)
		}
	} else if value > node.Value {
		// 值 比当前结点的值 大
		// 添加在右子结点
		if node.Right == nil {
			// 右子树为空 添加
			node.Right = &BinarySearchTreeNode{Value: value}
		} else {
			// 右子树不为空 递归寻找
			node.Right.addNode(value)
		}
	} else {
		// 相等记录出现次数
		node.Times++
	}
}
```
如果添加元素时是棵空树，那么初始化根节点。

然后添加的值和根节点比较，判断是要插入到根节点左子树还是右子树，还是不用插入。

当值比根节点小时，元素要插入到根节点的左子树中，当值比根节点大时，元素要插入到根节点的右子树中，相等时不插入，只更新次数。

然后再分别对根节点的左子树和右子树进行递归操作即可。

### 查找最大值和最小值
查找最大值和最小值比较简单，一直往左儿子往下找左儿子，可以找到最小的元素，
一直往右儿子找右儿子，可以找到最大的元素。

```go
// FindMinValue 查找最小值
func (tree *BinarySearchTree) FindMinValue() *BinarySearchTreeNode {
	if tree.Root == nil {
		return nil
	}

	return tree.Root.findMinValue()
}
// findMinValue 递归查询左子树
func (node *BinarySearchTreeNode) findMinValue() *BinarySearchTreeNode {
	// 左子树为空，表面已经是最左的节点了，该值就是最小值
	if node.Left == nil {
		return node
	}
	// 一直左子树递归
	return node.Left.findMinValue()
}

// FindMaxValue 查找最大值
func (tree *BinarySearchTree) FindMaxValue() *BinarySearchTreeNode {
	if tree.Root == nil {
		return nil
	}
	return tree.Root.findMaxValue()
}
// findMaxValue 递归查找最大值
func (node *BinarySearchTreeNode) findMaxValue() *BinarySearchTreeNode {
	if node.Right == nil {
		return node
	}

	// 递归查找又子树
	return node.Right.findMaxValue()
}
```
### 查找指定元素
```go
// Find 查找指定元素
func (tree *BinarySearchTree) Find(value int64) *BinarySearchTreeNode  {
	if tree.Root == nil {
		return nil
	}
	return tree.Root.find(value)
}
// find 递归查找结点
func (node *BinarySearchTreeNode) find(value int64) *BinarySearchTreeNode  {
	// 指定值 等于当前节点值 返回当前节点指针
	if value == node.Value || node == nil{
		return node
	}
	// 指定值 比当前节点值 小
	if value < node.Value {
		//// 递归查询左子树
		//if node.Left == nil {
		//	// 左子树为空，则没有查找到该值 返回nil
		//	return nil
		//}
		// 否则递归查找左子树
		return node.Left.find(value)
	} else {
		//// 指定值 比当前节点值 大
		//// 递归查找右子树
		//if node.Right == nil{
		//	// 当前节点右子树指针为空，表示没有查找到值 则返回nil
		//	return nil
		//}
		// 否则递归查找右子树
		return node.Right.find(value)
	}
}
```
如果是空树，返回 `nil`，否则与根节点比较。

如果刚刚好等于根节点的值，返回该节点，否则根据值的比较，继续往左子树或右字树递归查找。

### 查找指定元素的父节点

如果返回的父亲节点为空，表示没有父亲。
```go
// FindParent 查找指定元素的父节点
func (tree *BinarySearchTree) FindParent(value int64) *BinarySearchTreeNode  {
	// 空树
	if tree.Root == nil {
		return nil
	}
	// 当前值是根节点，没有父节点
	if tree.Root.Value == value {
		return nil
	}
	return tree.Root.findParent(value)
}
// findParent 查找指定值节点的父节点
func (node *BinarySearchTreeNode) findParent(value int64) *BinarySearchTreeNode {
	// 指定值 比当前节点值 小
	if value < node.Value {
		// 如果查找的值小于节点值，从节点的左子树开始找
		if node.Left == nil {
			// 左子树为空，表示找不到该值了，返回nil
			return nil
		}
		// 左子树的根节点的值刚好等于该值，那么父亲就是现在的node，返回
		if node.Left.Value == value {
			return node
		} else {
			return node.Left.findParent(value)
		}
	// 指定值 比当前节点值 大
	} else {
		if node.Right == nil {
			return nil
		}

		if node.Right.Value == value {
			return node
		} else {
			return node.Right.findParent(value)
		}
	}
}
```

### 删除节点
删除元素有四种情况：

1. 删除的节点是叶子节点，直接删除即可
   
2. 被删除的节点只有左子树，将被删除节点的左孩子替代被删除的节点即可

3. 被删除的节点只有右子树，将被删除节点的右孩子替代被删除节点即可

4. 被删除节点同时存在左子树和右子树，将其左子树中最大的节点替代被删除节点即可
   （或右子树中最小的节点替代即可）

```go
func (tree *BinarySearchTree) Delete(value int64)  {
	if tree.Root == nil {
		return
	}
	node := tree.Root.find(value)  // 查找值是否存在
	if node == nil {
		return
	}
	parent := tree.Root.findParent(value)  // 查找该值的父节点

	// 根节点 且没有子树
	if parent == nil && node.Left == nil && node.Right == nil {
		tree.Root = nil
		return
	}
	// 存在父节点 但是没有子结点 叶子节点
	if parent != nil && node.Left == nil && node.Right == nil {
		// 删除的节点是父节点的左左子结点 直接删除
		if parent.Left.Value == value {
			parent.Left = nil
		} else {
			parent.Right = nil
		}
		return
	}
	// 存在父节点 存在左子树 但是不存在右子树
	if parent != nil && node.Left != nil && node.Right == nil {
		// 直接将左孩子节点替代删除节点
		if parent.Left.Value == value {
			parent.Left = node.Left
		} else {
			parent.Right = node.Left
		}
		return
	}
	// 存在父节点 左子树为空，右子树不为空
	if parent != nil && node.Left == nil && node.Right != nil {
		// 直接将右孩子替代算法节点接口
		if parent.Left.Value == value {
			parent.Left = node.Right
		} else {
			parent.Right = node.Right
		}
		return
	}
	// 存在父节点 左子树和右子树均不为
	if parent != nil && node.Left != nil && node.Right != nil {
		// 寻找右子树中最小的节点替代被算法的节点
		// 只需要在右子树的左边寻找即可找到
		minNode := node.Right
		for minNode.Left != nil {
			minNode = minNode.Left
		}
		// 把最小的节点删掉
		tree.Delete(minNode.Value)
		// 使用最小节点替代
		// 最小值的节点替换被删除节点
		node.Value = minNode.Value
		node.Times = minNode.Times
		return
	}
}
```

### 中序遍历(排序)
二叉排序树的中序遍历输出的序列就是从小到大排列的序列
```go
// MidOrder 中序遍历
func (tree *BinarySearchTree) MidOrder() {
	tree.Root.midOrder()
}

func (node *BinarySearchTreeNode) midOrder() {
	if node == nil {
		return
	}

	// 先打印左子树
	node.Left.midOrder()

	// 按照次数打印根节点
	for i := 0; i <= int(node.Times); i++ {
		fmt.Print(node.Value, " ")
	}

	// 打印右子树
	node.Right.midOrder()
}
```

## 二叉排序树完整代码
```go
package main

import "fmt"

// BinarySearchTree 二叉查找树
type BinarySearchTree struct {
	Root *BinarySearchTreeNode // 树根节点
}

// BinarySearchTreeNode 二叉查找树节点
type BinarySearchTreeNode struct {
	Value int64                 // 值
	Times int64                 // 值出现的次数
	Left  *BinarySearchTreeNode // 左子树
	Right *BinarySearchTreeNode // 右字树
}

// NewBinarySearchTree 初始化一个二叉查找树
func NewBinarySearchTree() (t *BinarySearchTree) {
	t = new(BinarySearchTree)
	t.Root = nil
	return
}

// Add 给树添加结点
func (tree *BinarySearchTree) Add(value int64)  {
	// 根结点为空 添加根节点并返回
	if tree.Root == nil {
		tree.Root = &BinarySearchTreeNode{Value: value}
		return
	}
	// 否则 添加子结点
	tree.Root.addNode(value)
}
// addNode 给结点添加子结点
func (node *BinarySearchTreeNode) addNode(value int64)  {
	// 值 比当前结点的值 小
	// 添加在左子结点
	if value < node.Value {
		if node.Left == nil {
			// 左子树为空添加
			node.Left = &BinarySearchTreeNode{Value: value}
		} else {
			// 否则 继续递归寻找
			node.Left.addNode(value)
		}
	} else if value > node.Value {
		// 值 比当前结点的值 大
		// 添加在右子结点
		if node.Right == nil {
			// 右子树为空 添加
			node.Right = &BinarySearchTreeNode{Value: value}
		} else {
			// 右子树不为空 递归寻找
			node.Right.addNode(value)
		}
	} else {
		// 相等记录出现次数
		node.Times++
	}
}

// FindMinValue 查找最小值
func (tree *BinarySearchTree) FindMinValue() *BinarySearchTreeNode {
	if tree.Root == nil {
		return nil
	}

	return tree.Root.findMinValue()
}
// findMinValue 递归查询左子树
func (node *BinarySearchTreeNode) findMinValue() *BinarySearchTreeNode {
	// 左子树为空，表面已经是最左的节点了，该值就是最小值
	if node.Left == nil {
		return node
	}
	// 一直左子树递归
	return node.Left.findMinValue()
}

// FindMaxValue 查找最大值
func (tree *BinarySearchTree) FindMaxValue() *BinarySearchTreeNode {
	if tree.Root == nil {
		return nil
	}
	return tree.Root.findMaxValue()
}
// findMaxValue 递归查找最大值
func (node *BinarySearchTreeNode) findMaxValue() *BinarySearchTreeNode {
	if node.Right == nil {
		return node
	}

	// 递归查找又子树
	return node.Right.findMaxValue()
}

// Find 查找指定元素
func (tree *BinarySearchTree) Find(value int64) *BinarySearchTreeNode  {
	if tree.Root == nil {
		return nil
	}
	return tree.Root.find(value)
}
// find 递归查找结点
func (node *BinarySearchTreeNode) find(value int64) *BinarySearchTreeNode  {
	// 指定值 等于当前节点值 返回当前节点指针
	if node == nil || value == node.Value {
		return node
	}
	// 指定值 比当前节点值 小
	if value < node.Value {
		//// 递归查询左子树
		//if node.Left == nil {
		//	// 左子树为空，则没有查找到该值 返回nil
		//	return nil
		//}
		// 否则递归查找左子树
		return node.Left.find(value)
	} else {
		//// 指定值 比当前节点值 大
		//// 递归查找右子树
		//if node.Right == nil{
		//	// 当前节点右子树指针为空，表示没有查找到值 则返回nil
		//	return nil
		//}
		// 否则递归查找右子树
		return node.Right.find(value)
	}
}

// FindParent 查找指定元素的父节点
func (tree *BinarySearchTree) FindParent(value int64) *BinarySearchTreeNode  {
	// 空树
	if tree.Root == nil {
		return nil
	}
	// 当前值是根节点，没有父节点
	if tree.Root.Value == value {
		return nil
	}
	return tree.Root.findParent(value)
}
// findParent 查找指定值节点的父节点
func (node *BinarySearchTreeNode) findParent(value int64) *BinarySearchTreeNode {
	// 指定值 比当前节点值 小
	if value < node.Value {
		// 如果查找的值小于节点值，从节点的左子树开始找
		if node.Left == nil {
			// 左子树为空，表示找不到该值了，返回nil
			return nil
		}
		// 左子树的根节点的值刚好等于该值，那么父亲就是现在的node，返回
		if node.Left.Value == value {
			return node
		} else {
			return node.Left.findParent(value)
		}
	// 指定值 比当前节点值 大
	} else {
		if node.Right == nil {
			return nil
		}

		if node.Right.Value == value {
			return node
		} else {
			return node.Right.findParent(value)
		}
	}
}


/*
1. 删除的节点是叶子节点，直接删除即可

2. 被删除的节点只有左子树，将被删除节点的左孩子替代被删除的节点即可

3. 被删除的节点只有右子树，将被删除节点的右孩子替代被删除节点即可

4. 被删除节点同时存在左子树和右子树，将其左子树中最大的节点替代被删除节点即可
   （或右子树中最小的节点替代即可）
 */

func (tree *BinarySearchTree) Delete(value int64)  {
	if tree.Root == nil {
		return
	}
	node := tree.Root.find(value)  // 查找值是否存在
	if node == nil {
		return
	}
	parent := tree.Root.findParent(value)  // 查找该值的父节点

	// 根节点 且没有子树
	if parent == nil && node.Left == nil && node.Right == nil {
		tree.Root = nil
		return
	}
	// 存在父节点 但是没有子结点 叶子节点
	if parent != nil && node.Left == nil && node.Right == nil {
		// 删除的节点是父节点的左左子结点 直接删除
		if parent.Left.Value == value {
			parent.Left = nil
		} else {
			parent.Right = nil
		}
		return
	}
	// 存在父节点 存在左子树 但是不存在右子树
	if parent != nil && node.Left != nil && node.Right == nil {
		// 直接将左孩子节点替代删除节点
		if parent.Left.Value == value {
			parent.Left = node.Left
		} else {
			parent.Right = node.Left
		}
		return
	}
	// 存在父节点 左子树为空，右子树不为空
	if parent != nil && node.Left == nil && node.Right != nil {
		// 直接将右孩子替代算法节点接口
		if parent.Left.Value == value {
			parent.Left = node.Right
		} else {
			parent.Right = node.Right
		}
		return
	}
	// 存在父节点 左子树和右子树均不为
	if parent != nil && node.Left != nil && node.Right != nil {
		// 寻找右子树中最小的节点替代被算法的节点
		// 只需要在右子树的左边寻找即可找到
		minNode := node.Right
		for minNode.Left != nil {
			minNode = minNode.Left
		}
		// 把最小的节点删掉
		tree.Delete(minNode.Value)
		// 使用最小节点替代
		// 最小值的节点替换被删除节点
		node.Value = minNode.Value
		node.Times = minNode.Times
		return
	}
}

// MidOrder 中序遍历
func (tree *BinarySearchTree) MidOrder() {
	tree.Root.midOrder()
}

func (node *BinarySearchTreeNode) midOrder() {
	if node == nil {
		return
	}

	// 先打印左子树
	node.Left.midOrder()

	// 按照次数打印根节点
	for i := 0; i <= int(node.Times); i++ {
		fmt.Print(node.Value, " ")
	}

	// 打印右子树
	node.Right.midOrder()
}

func main() {

	var t *BinarySearchTree
	t = NewBinarySearchTree()
	values := []int64{9,2,3,7,1,4,10,8,6,5}
	for _, v := range values {
		t.Add(v)
	}

	t.MidOrder()

}
```

# 二 AVL树(平很二叉树)
二叉查找树的树高度影响了查找的效率，需要尽量减小树的高度，AVL树正是这样的树。

## AVL树介绍

`AVL`树是一棵严格自平衡的二叉查找树，`1962`年，发明者 `Adelson-Velsky` 和 `Landis` 
发表了论文，以两个作者的名字命名了该数据结构，这是较早发明的平衡二叉树。

定义如下：
1. 首先它是一棵二叉查找树。
2. 任意一个节点的左右子树最大高度差为1。

由于树特征定义，我们可以计算出其高度 `h` 的上界 `h<=1.44log(n)`，
也就是最坏情况下，树的高度约等于 `1.44log(n)`

> 假设高度 h 的AVL树最少有 f(h) 个节点，因为左右子树的高度差不能大于1，
> 所以左子树和右子树最少节点为： f(h-1)，f(h-2)。
> 
> 因此，树根节点加上左右子树的节点，满足公式 f(h) = 1 + f(h-1) + f(h-2)，
> 初始条件 f(0)=0,f(1)=1。
> 
> 经过数学的推算可以得出 h<=1.44log(n)，由于计算过程超纲了，在此不进行演算。

树的高度被限制于 `1.44log(n)`， 所以查找元素时使用二分查找，最坏查找 `1.44log(n)` 次，
此时最坏时间复杂度为 `1.44log(n)`，去掉常数项，时间复杂度为：`log(n)`。

为了维持`AVL`树的特征，每次添加和删除元素都需要一次或多次旋转来调整树的平衡。
调整的依据来自于二叉树节点的平衡因子：节点的左子树与右子树的高度差称为该节点的平衡因子，
约束范围为 `[-1，0，1]`。

平衡二叉查找树比较难以理解的是添加和删除元素时的调整操作，我们将会具体分析。



