# 面向对象
在go语言中是没有类的概念的，面向对象的实现是通过结构体实现的。

之前涉及到结构体就是面向对象对数据的封装过程

# 一 继承
![img.png](.img/继承.png)
根据上面的图，我们发现学生类(结构体)，讲师类(结构体)等都有共同的成员（属性和方法），
这样就存在重复，所以我们把这些重复的成员封装到一个父类（结构体）中。
然后让学生类(结构体)和讲师类(结构体)继承父类(结构体)接下来，
我们可以先将公共的属性，封装到父类（结构体）中实现继承,
关于方法(函数)的继承后面再讲

## 1.1 匿名字段创建与初始化
go语言中实现继承是通过匿名字段来完成继承的。
```go
package main

import "fmt"

func main() {
	type Person struct { // 定义结构体类型
		name string
		age  int
		gender string
	}

	type Student struct {
		Person  // 匿名字段，继承Person结构体中属性和方法
		id int
		score int
	}

	var student Student = Student{
		Person: Person{"dyp", 19,"男"},
		id:     101,
		score:  89,
	}

	fmt.Println(student) // {{dyp 19 男} 101 89}

	var student1 Student
	student1.name = "dyy"
	student1.age = 12
	student1.gender = "男"
	student1.id = 102
	student1.score = 99

	fmt.Println(student1)
}
```
**匿名字段默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。**

## 1.2 同名字段
父结构体中的字段与子结构体中的字段重名时处理
```go
package main

import "fmt"

func main() {
	type Person struct { // 定义结构体类型
		name string
		age  int
		gender string
	}

	type Student struct {
		Person  // 匿名字段，继承Person结构体中属性和方法
		id int
		score int
		name string  // 重名字段
	}


	var student1 Student
	student1.name = "dyy"  // 使用子结构体中的字段
	student1.Person.name = "dhs"  // 父结构体中字段
	student1.age = 12
	student1.gender = "男"
	student1.id = 102
	student1.score = 99

	fmt.Println(student1)
}
```
* 对于同名字段，结构体变量在使用时，
  需要**首先访问的是自己的字段，最后在访问父结构体字段**
* 在多继承中，出现了同名字段，需要指定父结构体进行访问

## 1.3 指针类型的匿名字段
匿名字段是指针变量代替。
```go
package main

import "fmt"

func main() {
    type Person struct { // 定义结构体类型
      name string
      age  int
      gender string
    }
    
    type Driver struct {
      *Person  // 指针匿名字段，继承Person结构体中属性和方法
      id int
      name string  // 重名字段
    }
  
    var driver Driver
    driver.Person = new(Person)  // 需要手动初始化指针匿名字段分配内存
    driver.name = "dyp"
    driver.id = 103
    driver.Person.name = "dyd"  // error
    driver.gender = "男"
    driver.age = 25
    fmt.Println(driver)  // {0xc000142390 103 dyp}

}
```
* 对于**指针匿名变量在使用之前需要首先进行初始化**

## 1.4 多继承
go语言中结构体多出继承关系如下
```go
package main

func main() {
	type Object struct {
		id int
		flag bool
	}

	type Person struct { // 定义结构体类型
		Object
		name string
		age  int
		gender string
	}

	type Student struct {
		Person  // 匿名字段，继承Person结构体中属性和方法
		id int
		score int
		name string  // 重名字段
	}
}
```
**Student继承了Object和Person**这是第一种多继承继承关系

还可支持继承多个结构体

```go
package main

func main() {
    type Object struct {
      id   int
      flag bool
    }
  
    type Person struct { // 定义结构体类型
      name   string
      age    int
      gender string
    }
  
    type Driver struct {
      Person
      Object
      *Driver 
      //Driver  // error
      id int
    }
}
```
**不能继承自己，但是可以通过指针匿名字段进行继承自己**


# 二 方法
`Go`语言中的方法(`Method`)是一种作用于**特定类型变量的函数**, 例如
```go
package main

type MyInt int

func (a MyInt) add(b MyInt) MyInt {
	return a + b
}
```
**go语言是不能给基本类型绑定方法**

## 2.1 方法绑定和接收者
**特定类型变量**叫做接收者(`Receiver`)。
接收者的概念就类似于其他语言中的`this`或者`self`

**方法语法如下**
```
func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
    函数体
}
```
* `接收者变量`：接收者中的参数变量名在命名时，官方建议使用**接收者类型名称首字母的小写**，而不是`self、this`之类的命名。
  例如，`Person`类型的接收者变量应该命名为`person`，`Connector`类型的接收者变量应该命名为`connector`等。
* `接收者类型`：接收者类型和参数类似，可以是指针类型和非指针类型。
  * 指针类型类型接收者使用条件
    1. 需要**修改接收者中的值**
    2. 接收者是**拷贝代价比较大**的大对象
    3. **保证一致性**，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。
* 方法名、参数列表、返回参数：具体格式与函数定义相同

**方法是不能调用的，需要通过该类型的变量调用**

**示例**
```go
package main

import "fmt"

type MyInt int

func (a MyInt) add(b MyInt) MyInt {
    return a + b
}

type Person struct { // 定义结构体类型
    name string
    age  int
    gender string
}

func (p Person)info() {
    fmt.Printf("name:%s-age:%d-gender:%s\n", p.name, p.age, p.gender)
}

func (p *Person)edit(name string, age int, gender string) {
    p.name = name
    p.age = age
    p.gender = gender
}

func main() {
    var person = Person{
      name:   "dyp",
      age:    25,
      gender: "男",
    }
    person.info()  //  修改前 name:dyp-age:25-gender:男
    person.edit("dyy", 17, "女")
    person.info()  // 修改后 name:dyy-age:17-gender:女
}
```

### 构造函数
`Go`语言的结构体没有构造函数，我们可以自己实现。 
例如，下方的代码就实现了一个`person`的构造函数。 
因为`struct`是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，
所以该构造函数返回的是结构体指针类型。
```go
package main

type person struct {
  name string
  city string
  age  int8
}

func newPerson(name, city string, age int8) *person {
	return &person{
		name: name,
		city: city,
		age:  age,
	}
}
```

**练习**
```go
package main

import "fmt"

type Score struct {
	chinese int
	math int
	english int
}

type Student struct { // 定义结构体类型
	name string
	age  int
	gender string
	Score
}

// 构造函数
func InitStudent(name string, age int, gender string, chinese, math, english int) *Student {
	return &Student{
		name:   name,
		age:    age,
		gender: gender,
		Score:  Score{
			chinese: chinese,
			math:    math,
			english: english,
		},
	}
}

func (s Student)hello() {
	fmt.Printf("我叫%s，性别%s，今年%d岁\n", s.name, s.gender, s.age)
}

func (s Student)hi()  {
	totalScore := s.chinese+s.math+s.english
	avgScore := totalScore /3
	fmt.Printf("我叫%s，考试总分为%d，平均分为%d\n", s.name, totalScore, avgScore)
}

func main() {
	student := InitStudent("dyp", 19, "男", 98, 99, 87)
	student.hello()  // 打招呼
	student.hi()  // 
}
```

## 2.2 方法继承与重写
子结构体会继承父结构体的所有字段，包括绑定给父结构体的方法。
但是，父类不能使用子类的字段和方法

**练习1：根据以下信息，实现对应的继承关系** 
* 记者：我是记者  我的爱好是偷拍 我的年龄是34 我是一个男狗仔
* 程序员：我叫孙权 我的年龄是23 我是男生 我的工作年限是 3年

```go
package main

import "fmt"

// 公共属性
type Person struct { // 定义结构体类型
	name string
	age  int
	gender string
}
func InitPerson(name, gender string, age int) *Person{
	return &Person{
		name:   name,
		age:    age,
		gender: gender,
	}
}
func (p *Person)SayHello() {
	fmt.Printf("我叫%s, 今年%d岁 我是%s生 ", p.name, p.age, p.gender)
}

// 记者
type Reporter struct {
	*Person  // 继承公共属性
	hobby string
}
// 构造实例
func initReporter(name, gender, hobby string, age int) *Reporter {
	return &Reporter{
		Person:  InitPerson(name, gender, age),
		hobby:  hobby,
	}
}

func (r *Reporter)SayHi(){
	r.Person.SayHello()
	fmt.Printf("我的爱好是%s\n", r.hobby)
}
// 程序员
type Programmer struct {
	*Person
	workYear int
}
// 构造实例
func initProgrammer(name, gender string, age, workYear int) * Programmer {
	return &Programmer{
		Person:   InitPerson(name, gender, age),
		workYear: workYear,
	}
}

func (p *Programmer)SayHi(){
	p.Person.SayHello()
	fmt.Printf("我工作%d年了\n", p.workYear)
}
func main() {

	reporter := initReporter("dyy", "男", "偷拍", 34)
	programmer := initProgrammer("孙权", "男", 23,3)
	reporter.SayHi()
	programmer.SayHi()
}
```

### 方法重写

当给子结构体绑定了与父结构体同名的方法时，称为方法重写
```go
package main

import "fmt"

// 公共属性
type Person struct { // 定义结构体类型
	name string
	age  int
	gender string
}
func InitPerson(name, gender string, age int) *Person{
	return &Person{
		name:   name,
		age:    age,
		gender: gender,
	}
}
func (p *Person)SayHello() {
	fmt.Printf("我叫%s, 今年%d岁 我是%s生 ", p.name, p.age, p.gender)
}

// 记者
type Reporter struct {
	*Person  // 继承公共属性
	hobby string
}
// 构建记者对象
func initReporter(name, gender, hobby string, age int) *Reporter {
	return &Reporter{
		Person:  InitPerson(name, gender, age),
		hobby:  hobby,
	}
}
// 从而写父结构体的SayHello的方法
func (r *Reporter)SayHello(){
	r.Person.SayHello()
	fmt.Printf("我的爱好是%s\n", r.hobby)
}


// 程序员
type Programmer struct {
	*Person
	workYear int
}
// 构建程序员对象
func initProgrammer(name, gender string, age, workYear int) * Programmer {
	return &Programmer{
		Person:   InitPerson(name, gender, age),
		workYear: workYear,
	}
}
// 从而写父结构体的SayHello的方法
func (p *Programmer)SayHello(){
	p.Person.SayHello()
	fmt.Printf("我工作%d年了\n", p.workYear)
}
func main() {
	reporter := initReporter("dyy", "男", "偷拍", 34)
	programmer := initProgrammer("孙权", "男", 23,3)
	reporter.SayHello()  // 优先调用子结构的方法
	programmer.SayHello()
}
```
**一个对象中，不能出现相同的方法名**

## 2.3 方法类型

方法实际上就是函数，只是对函数进行了修改。怎样定义函数类型就怎样定义方法类型
```go
package main

import "fmt"

// 公共属性
type Person struct { // 定义结构体类型
	name string
	age  int
	gender string
}
func InitPerson(name, gender string, age int) *Person{
	return &Person{
		name:   name,
		age:    age,
		gender: gender,
	}
}
func (p *Person)SayHello() {
	fmt.Printf("我叫%s, 今年%d岁 我是%s生 ", p.name, p.age, p.gender)
}

// 记者
type Reporter struct {
	*Person  // 继承公共属性
	hobby string
}

func initReporter(name, gender, hobby string, age int) *Reporter {
	return &Reporter{
		Person:  InitPerson(name, gender, age),
		hobby:  hobby,
	}
}

func (r *Reporter)SayHello(){
	r.Person.SayHello()
	fmt.Printf("我的爱好是%s\n", r.hobby)
}
// 程序员
type Programmer struct {
	*Person
	workYear int
}

func initProgrammer(name, gender string, age, workYear int) * Programmer {
	return &Programmer{
		Person:   InitPerson(name, gender, age),
		workYear: workYear,
	}
}

func (p *Programmer)SayHello(){
	p.Person.SayHello()
	fmt.Printf("我工作%d年了\n", p.workYear)
}
func main() {
	reporter := initReporter("dyy", "男", "偷拍", 34)
	programmer := initProgrammer("孙权", "男", 23,3)
	reporter.SayHello()
	programmer.SayHello()
	type methodType func()  // 定义方法类型
	var hello methodType  // 定义方法类型变量
	hello = reporter.SayHello  // 初始化
	hello()  // 通过方法变量调用方法
}
```

## 2.4 案例: 面向对象的学生管理系统
```go
package main

//大概的写了一下，并不完善。
import (
	"fmt"
	"sort"
)

type Student struct {
	ID    int
	Name  string
	Age   int8
	Score int8
}

//考虑到修改和删除，还是map比较合适
type Class struct {
	Map map[int]*Student
}

//添加学生
func (c *Class) AddStudent() {
	var id int
	var name string
	var age int8
	var score int8
	fmt.Print("输入id: ")
	_, err := fmt.Scan(&id)
	fmt.Print("输入姓名: ")
	_, err = fmt.Scan(&name)
	fmt.Print("输入年龄: ")
	_, err = fmt.Scan(&age)
	fmt.Print("输入分数: ")
	_, err = fmt.Scan(&score)
	if err != nil {
		fmt.Println("保存出错！")
	}
	_, isSave := c.Map[id]
	if isSave {
		fmt.Println("学生ID已存在！")
		return
	}
	student := &Student{
		ID:    id,
		Name:  name,
		Age:   age,
		Score: score,
	}
	c.Map[id] = student
	fmt.Println("保存成功！")
}

//查看学生列表
func (c *Class) ShowStudent() {
	fmt.Printf("\t%s\t%s\t%s\t%s\n", "ID", "姓名", "年龄", "分数")
	sortID := make([]int, 0)
	for k := range c.Map {
		sortID = append(sortID, k)
	}
	sort.Ints(sortID)
	for _, k := range sortID {
		s := c.Map[k]
		fmt.Printf("\t%d\t%s\t%d\t%d\n", s.ID, s.Name, s.Age, s.Score)
	}
}

//删除学生
func (c *Class) DeleteStudent() {
	fmt.Print("输入要删除的学生ID：")
	var id int
	_, err := fmt.Scan(&id)
	if err != nil {
		fmt.Println("err 好烦啊。")
	}
	_, isSave := c.Map[id]
	if !isSave {
		fmt.Println("要删除的ID不存在！")
		return
	}
	delete(c.Map, id)
	fmt.Println("删除成功！！")
}

//修改学生信息
func (c *Class) ChangeStudent() {
	fmt.Print("输入要修改的学生ID：")
	var id int
	_, err := fmt.Scan(&id)
	if err != nil {
		fmt.Println("err 好烦啊。")
	}
	_, isSave := c.Map[id]
	if !isSave {
		fmt.Println("要修改的ID不存在！")
		return
	}
	var name string
	var age int8
	var score int8
	fmt.Print("输入姓名: ")
	_, err = fmt.Scan(&name)
	fmt.Print("输入年龄: ")
	_, err = fmt.Scan(&age)
	fmt.Print("输入分数: ")
	_, err = fmt.Scan(&score)
	if err != nil {
		fmt.Println("保存出错！")
	}
	student := &Student{
		ID:    id,
		Name:  name,
		Age:   age,
		Score: score,
	}
	c.Map[id] = student
	fmt.Println("修改成功！")

}

func main() {
	c := &Class{}
	c.Map = make(map[int]*Student, 50)
	for {
		fmt.Println("要执行的操作：")
		fmt.Print("1. 添加  2.查看  3.删除  4.修改")
		var do int8
		_, err := fmt.Scan(&do)
		if err != nil {
			fmt.Println("输入有误！")
		}
		switch do {
		case 1:
			c.AddStudent()
		case 2:
			c.ShowStudent()
		case 3:
			c.DeleteStudent()
		case 4:
			c.ChangeStudent()
		default:
			fmt.Println("输入有误！")
		}
	}
}
```

# 三 多态

**面向对象设计一个计算器**
```go
package main

import "fmt"

// 面向对象计算器实现
// 计算器基类
type ObjectOperate struct {
	num1 int
	num2 int
}

// 加法类
type addClass struct {
	ObjectOperate
}

func (add addClass) plus() int {
	return add.num1 + add.num2
}

// 减法类
type subClass struct {
	ObjectOperate
}

func (sub subClass) minus() int {
	return sub.num2 - sub.num1
}


func main() {
	var add addClass
	add.num2 = 10
	add.num1 = 20

	sum := add.plus()
	fmt.Println(sum)

	var sub subClass
	sub.num1 = 10
	sub.num2 = 20
	minus := sub.minus()
	fmt.Println(minus)
}
```
该设计有个问题，我们使用每一个运算时都需要新建一个对象。需求发生变化都需要
修改大量的代码。

## 3.1 接口

接口就是一种规范和标准，用于限制子类行为的。接口是实现代码的，需要在子类中
进行代码实现

在Go语言中接口（`interface`）是一种类型，一种抽象的类型。

`interface`是一组`method`的集合，是`duck-type programming`的一种体现。
接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，
我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。

**接口定义**
```
type 接口名 interface{
    方法名1( 参数列表1 ) 返回值列表1
    方法名2( 参数列表2 ) 返回值列表2
    …
}
```
* `接口名`：使用`type`将接口定义为自定义的类型名。
  `Go`语言的接口在命名时，一般会在单词后面添加`er`，
  如有写操作的接口叫`Writer`，有字符串功能的接口叫`Stringer`等。
  接口名最好要能突出该接口的类型含义。
* `方法名`：当**方法名首字母是大写且这个接口类型名首字母也是大写**时，
  这个方法可以被接口所在的包（`package`）之外的代码访问。
* `参数列表、返回值列表`：参数列表和返回值列表中的参数变量名可以**省略**。


### 使用接口的好处
例如下面代码
```go
package main

import "fmt"

type Cat struct{}

func (c Cat) Say() string { return "喵喵喵" }

type Dog struct{}

func (d Dog) Say() string { return "汪汪汪" }

func main() {
	c := Cat{}
	fmt.Println("猫:", c.Say())
	d := Dog{}
	fmt.Println("狗:", d.Say())
}
```
上面的代码中定义了`猫和狗`，然后它们都会叫，你会发现`main`函数中明显有重复的代码，
如果我们后续再加上`猪、青蛙`等动物的话，我们的代码还会一直重复下去。
那我们能不能把它们当成“能叫的动物”来处理呢？

像类似的例子在我们编程过程中会经常遇到：
* 比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，
  我们能不能把它们当成“支付方式”来处理呢？

* 比如三角形，四边形，圆形都能计算周长和面积，
  我们能不能把它们当成“图形”来处理呢？

* 比如销售、行政、程序员都能计算月薪，
  我们能不能把他们当成“员工”来处理呢？

Go语言中为了解决类似上面的问题，就设计了接口这个概念。
接口区别于我们之前所有的具体类型，接口是一种抽象的类型。
当你看到一个接口类型的值时，你不知道它是什么，
唯一知道的是通过它的方法能做什么。

**一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个 *需要实现的方法列表*。**

**实现一个能叫动物的接口**
```go
package main

import "fmt"

// Sayer 接口
type Sayer interface {
	say()
}
type dog struct {}

type cat struct {}

// dog实现了Sayer接口
func (d dog) say() {
	fmt.Println("汪汪汪")
}

// cat实现了Sayer接口
func (c cat) say() {
	fmt.Println("喵喵喵")
}
```
## 3.2 接口类型变量
**接口类型变量能够存储所有实现了该接口的实例**。 例如上面的示例中，
`Sayer`类型的变量能够存储`dog`和`cat`类型的变量

```go
package main

import "fmt"

// Sayer 接口
type Sayer interface {
	say()
}
type dog struct {}

type cat struct {}

// dog实现了Sayer接口
func (d dog) say() {
	fmt.Println("汪汪汪")
}

// cat实现了Sayer接口
func (c cat) say() {
	fmt.Println("喵喵喵")
}

func main() {

	var x Sayer // 声明一个Sayer类型的变量x
	a := cat{}  // 实例化一个cat
	b := dog{}  // 实例化一个dog
	x = a       // 可以把cat实例直接赋值给x
	x.say()     // 喵喵喵
	x = b       // 可以把dog实例直接赋值给x
	x.say()     // 汪汪汪
}
```


## 3.3 通过接口实现多态
多态是指不同的子类存在的不同状态，对同样的接口有着不同形式的表现

go语言区别与python。在python中只需要在不同子类中定义相同的方法名即可实现多态。
而在go语言中实现多态需要通过定义一个函数接收接口类型变量来实现多态。
```go
package main

import "fmt"

// Sayer 接口
type Sayer interface {
	say()
}
type dog struct{}

type cat struct{}

// dog实现了Sayer接口
func (d dog) say() {
	fmt.Println("汪汪汪")
}

// cat实现了Sayer接口
func (c cat) say() {
	fmt.Println("喵喵喵")
}

func say(s Sayer) {
	s.say()
}

func main() {
	
	a := cat{}  // 实例化一个cat
	b := dog{}  // 实例化一个dog

	say(a)  // 喵喵喵
	//say(&a)  // 喵喵喵
    say(b)  // 汪汪汪
    //say(&b)  // 汪汪汪
}
```
可以直接将实现了接口中所有方法的结构体传递到这个函数中，对于不同的结构体实例传递
该函数中，则表现出不同的状态

**练习，用多态来实现，将移动硬盘或者U盘或者MP3插到电脑上进行读写数据（分析类，接口，方法）**


```go
package main

import "fmt"

// 存储设备接口
type StorageDevice interface {
  Write() // 写入数据
  Read() // 读取数据
}

// 存储设备
type Disk struct {
  id int  // 设备id
  memory int  // 存储容量
  speed float64   // 存储速度
}

// 移动硬盘
type MobileDisk struct {
  Disk  // 继承
  name string  // 硬盘名称
}

func (md MobileDisk) Write()  {
  fmt.Printf("%s-%d,正在写入数据，写入速度为%.2fmb/s\n",md.name, md.id, md.speed)
}

func (md MobileDisk) Read()  {
  fmt.Printf("%s-%d,正在读取数据，读取速度为%.2fmb/s\n",md.name, md.id, md.speed)
}


// USB
type USBDisk struct {
  Disk
  name string
}


func (ud USBDisk) Write()  {
  fmt.Printf("%s-%d,正在写入数据，写入速度为%.2fmb/s\n",ud.name, ud.id, ud.speed)
}

func (ud USBDisk) Read()  {
  fmt.Printf("%s-%d,正在读取数据，读取速度为%.2fmb/s\n",ud.name, ud.id, ud.speed)
}

// mp3
type Mp3Disk struct {
  Disk
  name string
}

func (pd Mp3Disk) Write()  {
  fmt.Printf("%s-%d,正在写入数据，写入速度为%.2fmb/s\n",pd.name, pd.id, pd.speed)
}

func (pd Mp3Disk) Read()  {
  fmt.Printf("%s-%d,正在读取数据，读取速度为%.2fmb/s\n",pd.name, pd.id, pd.speed)
}

// 多态
func Write(s StorageDevice) {
  s.Write()
}

func Read(s StorageDevice) {
  s.Read()
}

func main(){
  var mobileDisk MobileDisk = MobileDisk{
    Disk: Disk{
      id:     101,
      memory: 200,
      speed:  45.3,
    },
    name: "移动硬盘",
  } // 移动硬盘

  Write(mobileDisk)
  Read(&mobileDisk)
  var usbDisk USBDisk = USBDisk{
    Disk: Disk{
      id:     102,
      memory: 128,
      speed:  23.4,
    },
    name: "USB",
  }
  Write(usbDisk)
  Read(&usbDisk)

  var mp3Disk Mp3Disk = Mp3Disk{
    Disk: Disk{
      id:     103,
      memory: 64,
      speed:  12.5,
    },
    name: "MP3",
  }
  Write(mp3Disk)
  Read(&mp3Disk)
}
```
* 对于值接收者实现的接口，给接口变量赋值是可以直接赋值或者取地址赋值
* 对于指针接收者实现的接口，给接口变量赋值时必须使用地址赋值

## 3.3 接口的继承与转换

go中接口是可以继承。一个接口如果继承了某个即可称该接口为超集，而被继承的
接口称为子集。

```go
package main
type Test1 interface { // 子集
	hello()
}

type Test2 interface {  // 超集
	Test1  // 继承了一个接口
	read()
}
```
**转换:** **指超集转为子集，但是反之不行**，指子集类型的变量可以使用接收超集类型的值

## 3.4 空接口
空接口(`interface{}`)不包含任何的方法，正因为如此，
所有的类型都实现了空接口，因此空接口可以存储任意类型的数值

```go
package main

import "fmt"

func main(){

	var i interface{}  // 定义一个空接口类型
	i = 10
	fmt.Printf("数据: %v, 类型: %T, 地址: %p\n", i, i, &i)  // 数据: 10, 类型: int, 地址: 0xc0000442a0
	i = "hello world"
	fmt.Printf("数据: %v, 类型: %T, 地址: %p\n", i, i, &i)  // 数据: 10, 类型: int, 地址: 0xc0000442a0
}
```
* 可以定义空接口类型的数组、切片等等

### 3.4.1 类型断言

空接口可以保存任何类型的数据，对数据操作是需要知道类型是否支持该操作。
使用类型断言语句可以实现,语法为:`data, is_true := 数据.(type)`
* `type`: 判断数据是否为`type`类型 
* `data`: 数据
* `is_ture`: 数据数据类型为`type`返回`true`, 否则返回`false`


## 3.5 面向对象示例
**使用面向对象的思想设计一个计算器**

```go
package main

import "fmt"

// ObjectOperate 面向对象计算器实现
// 计算器基类
type ObjectOperate struct {
    num1 int
    num2 int
}

// 加法类
type addClass struct {
    ObjectOperate
}

func (add *addClass) Operate() int {
    return add.num1 + add.num2
}

// 减法类
type subClass struct {
    ObjectOperate
}

func (sub *subClass) Operate() int {
    return sub.num2 - sub.num1
}

// Operation 接口
type Operation interface {
    Operate() int
}

// OptFactory 多态实现
func OptFactory(o Operation) (value int) {
    value = o.Operate()
    return
}

// Factory 工厂模式，空结构体
type Factory struct {
}

// Calc 工厂函数
func (f *Factory) Calc(number1, number2 int, op string) (value int) {
    // 接口类型变量
    var opt Operation
    switch op {
        case "+":
            var add addClass = addClass{ObjectOperate{number1, number2}} // 创建加法对象
            opt = &add                                                   // 绑定对象
        case "-":
            var sub subClass = subClass{ObjectOperate{number1, number2}} // 创建减法对象
            opt = &sub                                                   // 绑定的对象
    }
    //value = opt.Operate()  // 调用接口
    value = OptFactory(opt)
    return
}

func main() {
    var factory Factory
    value := factory.Calc(10, 20, "+")
    fmt.Println(value)
}
```
如上设计，当需要添加新功能时**只需要在工厂函数中修改，然后在区实现需要的对象即可**

