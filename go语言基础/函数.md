# 函数基础

程序中不可避免的是会重复出现很多的代码，对于重复出现的代码，如果不进行重构，
将会造成程序代码冗余，后续修改也会增加难度。

将功能相似的代码封装到一个函数中，每次需要使用该重复代码时，只需要调用该函数即可。

## 一 函数的定义与使用

定义函数的基本语法为
```
func 函数名(形参数列表)(返回值列表) {
    函数体
}
```
* 使用关键字`func`来完成函数定义
* **参数列表和返回值列表是可选的**

定义函数后需要调用才会执行，调用函数语法: `返回值 = 函数名(实参数列表)`

**示例，函数的定义与使用**
```go
package main

import "fmt"

// 定义一个函数，返回两个数的和
func add(x int, y int) int {
	return x + y
}

func main() {
	z := add(10, 20)  // 调用函数
	fmt.Println(z)
}
```
* 先执行`main`函数，在`main`函数中调用了`add`函数
* 当`add`函数被调用时，转到`add`函数进行执行
* 当`add`函数被执行完成后，跳转回`main`函数继续执行之后的代码

**函数在创建时，会新建一个作用域，函数内部的变量只能在函数中使用**，离开函数后
函数中的数据将会在内存中被销毁。
****
在go语言中，**所有的函数都是全局函数，在一个包里面的不同文件，也不能定义相同的函数名**
****
go语言中，**函数是一等公民：函数可以复制给变量，可以当函数的返回值，
可以当成参数传递到函数中**

## 二 函数参数

### 参数类型简写
函数在定义时，参数可以进行类型简写,**如果相邻变量的类型相同，则可以省略类型**

**示例**
```go
package main

import "fmt"

// 参数简写
func add(x, y int) int {
	return x + y
}

func main() {
	z := add(10, 20)  // 调用函数
	fmt.Println(z)
}
```
### 不定长参数
不定长参数是指函数的参数数量不固定。`Go`语言中的可变参数通过在参数名后加`...`来标识
```go
package main

import "fmt"

func intSum(a ...int) int {
	sum := 0
	// 传递过来的参数被打包到了一个切片a中
	for _, v := range a{
		sum += v
	}
	return sum
}

func main() {
	z := intSum(1,2,3,4,5,6,7,8,9,10)
	fmt.Println(z)
}
```
****
**固定参数与不定定长参数一起使用时，需要将不定长参数放在最后**
```go
package main

import "fmt"

func intSum2(sum int, a ...int) int {
	for _, v := range a {
		sum += v
	}
	return sum
}

func main() {

	sum := 10
	z := intSum2(sum, 1,2,3,4,5,6,7,8,9,10)
	fmt.Println(z)
}
```

### 指针当作参数

go语言中，支持将指针当成参数传递到函数中，下面将以交换两个变量值为例
```go
package main

import "fmt"

func swap(a *int, b *int)  {
	*a, *b = *b, *a
}

func main() {
	a := 10
	b := 20
	fmt.Println("交换之前:", a, b)
	swap(&a, &b)
	fmt.Println("交换之后", a, b)
}
```
**初始化切片**
```go
package main

import "fmt"

func initSlice(slice *[]int) {
	*slice = make([]int, 0, 20)  // 初始化
	for i:=0; i<20; i++ {
		*slice = append(*slice, i)  // 添加值
	}
}

func main() {
	var slice []int
	initSlice(&slice)
	fmt.Println(slice)
}
```

## 三 函数嵌套调用
函数的嵌套使用，其实就是在一个**函数中调用另外的函数**。
```go
package main

import "fmt"

func main() {
	test1()
}


func test1() {
	test2()
	fmt.Println("test1")
}

func test2()  {
	fmt.Println("test2")
}
```
**输出结果**
```
test2
test1
```
**执行流程**
* 先执行`main`函数，由`main`发起对`test1`的调用
* 在执行`test1`，又发起了对`test2`的调用，进入`test2`中执行
* 当`test2`执行完成后，回到`test1`继续执行
* 当`test1`执行完成后，回到`main`中继续执行

## 四 返回值
Go语言中通过`return`关键字向外输出返回值

### 返回多值
支持返回多个值，如果有多个返回值时必须用`()`将所有返回值包裹起来

```go
package main

import "fmt"

func main() {
	x, y := calc(10, 20)
	fmt.Println(x, y)
}

func calc(x, y int) (int, int) {
	sum := x + y
	sub := x - y
	return sum, sub
}
```

### 返回值命名
函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过`return`关键字返回
```go
package main

import "fmt"

func main() {
	x, y := calc(10, 20)
	fmt.Println(x, y)
}

func calc(x, y int) (sum, sub int) {
	sum = x + y
	sub = x - y
	return
}
```

**返回值是切片时，`nil`是一个有效的返回值**


# 函数进阶

## 一 函数类型
go语言中函数是可以复制给一个变量的，变量又必须要有确定的类型，该类型就是函数类型

使用`type`定义函数类型，函数类型就是值该函数的传参与返回值的格式
```
type 类型名 func(参数类型列表) 返回值类型列表
```
* `func`: 关键字
* `type`: 关键字，用于重新命名类型(自定义类型)

**函数名是保存的函数的入口地址**，所以函数类型实际上是一个指针类型

```go
package main

import "fmt"

func calc(x, y int) (sum, sub int) {
	sum = x + y
	sub = x - y
	return
}
type funcType func(int, int)(int, int)  // 定义一个函数类型

func main() {
	var ca funcType  // 定义一个函数类型变量
	ca = calc  // 给变量复制
	x, y := 30, -10
	x, y = ca(x, y)  // 调用函数
	fmt.Println(x, y) 
}
```

* 函数类型是确定函数的传参和返回值的格式
* 如果格式一致是指传参和返回值的类型都是一样的。

## 二 作用域

go语言中，变量存在于不同的作用域中，变量的查找先冲局部变量查找到全局变量

### 2.1 局部作用域
go语言中区别作用域的是`{}`，因此`if`、`for`、`switch`和函数都会新建
局部作用域，局部作用域中变量只能在该作用域中使用，出了该区域变量立即被销毁。
* 对于局部作用域，变量的适用范围是在其定义之后。

### 2.2 全局作用域
函数外部的空间被整个工程全局捕获。所以只要是在函数外的区域都是全局作用域。
在全局作用域中的变量，在任何位置都是可以访问和修改。
* 在全局作用域中的变量，无论在那个函数前后定义，整个工程项目的所有文件都能访问
* 全局变量是可以获取地址的

```go
package main

import "fmt"

func test() {
	var c = 20  // c是局部变量，只能在函数test中使用
	fmt.Println(c)
}
func main() {
	fmt.Println(a)
	a = 20  // 函数内部可以修改全局变量
	fmt.Println(a)
	//fmt.Println(c) // 无法访问不变量c

	//fmt.Println(b)  // 无法访问变量b
	b := 30
	fmt.Println(b)  // 变量定义之后才能访问
}

var a int = 10  // 全局变量
```

## 三 匿名函数



